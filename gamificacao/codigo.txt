#include <Wire.h>
#include <Arduino.h>
#include "Adafruit_LiquidCrystal.h"


#define MAX_JOGADORES 6

enum EnderecosI2C
{
    PLAYER_A = 0x20,
    PLAYER_B = 0x21,
    PLAYER_C = 0x22,
    PLAYER_D = 0x23,
    PLAYER_E = 0x24,
    PLAYER_F = 0x25,
    PROFESSOR = 0x26
};

enum Botao
{
    BOTAO_INICIAR = 0b11011111,
    BOTAO_FINALIZAR = 0b11101111,
    BOTAO_A = 0b11110111,
    BOTAO_B = 0b11111011,
    BOTAO_C = 0b11111101,
    BOTAO_D = 0b11111110,
    BOTOES_JOGADOR = 0b00001111,
    BOTOES_MESTRE = 0b11111111,
    BOTAO_INVALIDO = 0b00000000
};




class Util
{
public:
    Util() {}

    static void escreverDado(uint8_t device, uint8_t byte);
    static uint8_t lerBotao(uint8_t device, uint8_t count, uint8_t mask);

};


class Jogador
{
private:
    char nome_;
    uint8_t pontuacao_;
    uint8_t resposta_;
    uint8_t endereco_;
    unsigned long tempo_anterior_;

public:

    Jogador(char nome, uint8_t endereco)
        : nome_(nome), pontuacao_(0), resposta_(0x0), endereco_(endereco),  tempo_anterior_(0) {}

    Jogador() : nome_(' '), pontuacao_(0), resposta_(0x0), endereco_(0),  tempo_anterior_(0) {}

    void verificarBotaoPressionado();
    void marcar_ponto(uint8_t ponto);
    void reiniciar_jogador();
    char obterNome();
    uint8_t obterPontuacao();
    void definirPontuacao(uint8_t ponto);
    uint8_t obterResposta();
    void definirResposta(uint8_t resposta);
    uint8_t obterEndereco();
    unsigned long obterTempoAnterior();
    void definirTempoAnterior(unsigned long tempo);



};


class Professor {

private:
  uint8_t endereco_;
  char nome_;

public:

  Professor(char nome, uint8_t endereco)
    : nome_(nome), endereco_(endereco) {}
  Professor()
    : nome_('P'), endereco_(0) {}


  Botao verificarBotaoPressionado();
  uint8_t obterEndereco();
  char obterNome();
};

class Jogo {
public:
  uint8_t rodadas;
  uint8_t rodadas_restantes;
  uint8_t resposta_certa;
  bool ativo;
  Jogador jogador[MAX_JOGADORES];
  Professor professor;

  Jogo(uint8_t rodadas)
    : rodadas(rodadas), rodadas_restantes(rodadas), resposta_certa(0x0), ativo(false) {
  }
  void iniciar_jogo();
  Botao definir_resposta_certa();
  void finalizarJogo();
  void reiniciar_jogadores();
  void verificar_botoes_jogadores();
  void pontuar_jogadores(Botao, uint8_t);
  void redefinir_respostas_jogadores();
};


char Jogador::obterNome() {
  return this->nome_;
}

uint8_t Jogador::obterPontuacao() {
  return this->pontuacao_;
}


uint8_t Jogador::obterResposta() {
  return this->resposta_;
}

void Jogador::definirResposta(uint8_t resposta) {
  this->resposta_ = resposta;
}
uint8_t Jogador::obterEndereco() {
  return this->endereco_;
}

unsigned long Jogador::obterTempoAnterior() {
  this->tempo_anterior_;
}

void Jogador::definirTempoAnterior(unsigned long tempo) {
  this->tempo_anterior_ = tempo;
}

void Jogador::definirPontuacao(uint8_t ponto) {
  this->pontuacao_ = ponto;
}

void Jogador::verificarBotaoPressionado() {
  uint8_t botao_pressionado_atual = Util::lerBotao(this->obterEndereco(), 1, 0b11111111);

  if (botao_pressionado_atual != BOTAO_INVALIDO && millis() - this->obterTempoAnterior() > 50) {
    this->definirTempoAnterior(millis());
    switch (botao_pressionado_atual) {
      case BOTAO_A:
        Serial.println("O jogador apertou a opcao 'A'");
        this->definirResposta(BOTAO_A);
        break;
      case BOTAO_B:
        Serial.println("O jogador apertou a opcao 'B'");
        this->definirResposta(BOTAO_B);
        break;
      case BOTAO_C:
        Serial.println("O jogador apertou a opcao 'C'");
        this->definirResposta(BOTAO_C);
        break;
      case BOTAO_D:
        Serial.println("O jogador apertou a opcao 'D'");
        this->definirResposta(BOTAO_D);
        break;
      default:
        this->definirResposta(BOTAO_INVALIDO);
        break;
    }
  }
}

void Jogador::marcar_ponto(uint8_t ponto) {
  uint8_t pontuacao = this->obterPontuacao() + ponto;
  this->definirPontuacao(ponto);
}

void Jogador::reiniciar_jogador() {
  Util::escreverDado(this->obterEndereco(), 0b11111111);
  this->definirResposta(BOTAO_INVALIDO);
}

Botao Jogo::definir_resposta_certa() {
    Botao botao_pressionado = BOTAO_INVALIDO;

    // Limpa eventos pendentes (ex.: ainda segurando Start)
    while (this->professor.verificarBotaoPressionado() != BOTAO_INVALIDO) {
        // fica até não haver evento
    }

    // Aguarda a primeira escolha válida (A/B/C/D) por borda
    while (true) {
        botao_pressionado = this->professor.verificarBotaoPressionado();
        if (botao_pressionado != BOTAO_INVALIDO) {
            return botao_pressionado;
        }
    }
}


void Jogo::redefinir_respostas_jogadores() {
  for (int i = 0; i < MAX_JOGADORES; i++) {
    this->jogador[i].definirResposta(0x0);
  }
}

void Jogo::reiniciar_jogadores() {
  for (int i = 0; i < MAX_JOGADORES; i++) {
    jogador[i].reiniciar_jogador();
  }
}

void Jogo::verificar_botoes_jogadores() {
  bool continuar = true;

  while (continuar) {
    for (int i = 0; i < MAX_JOGADORES; i++) {
      this->jogador[i].verificarBotaoPressionado();
    }
    if (this->jogador[0].obterResposta()) {
      continuar = false;
    }
    // TODO tempo de resposta dos usuarios
  }
}

void Jogo::pontuar_jogadores(Botao resposta, uint8_t pontos) {
  for (uint8_t i = 0; i < MAX_JOGADORES; i++) {
    if (this->jogador[i].obterResposta() == resposta) {
      this->jogador[i].marcar_ponto(pontos);
    }
  }
}

void Jogo::iniciar_jogo() {
  Serial.print("Jogo inicado!");
  this->ativo = true;
}

void Jogo::finalizarJogo() {
  Serial.print("Acabou o jogo!");
  this->ativo = false;
}
uint8_t Professor::obterEndereco(){
    return this->endereco_;
}
char Professor::obterNome(){
    return this->nome_;
}

Botao Professor::verificarBotaoPressionado()
{
    uint8_t atual = Util::lerBotao(this->obterEndereco(), 1, 0b11111111);

    static uint8_t anterior = BOTAO_INVALIDO;        // último botão lido
    static unsigned long t_ultima_mudanca = 0;       // para debounce
    unsigned long agora = millis();

    // Se não mudou, não há evento
    if (atual == anterior) return BOTAO_INVALIDO;

    // Mudou: aplica debounce (~50 ms)
    if (agora - t_ultima_mudanca < 50) return BOTAO_INVALIDO;

    // Confirma a mudança
    t_ultima_mudanca = agora;
    anterior = atual;

    // Dispara evento **só** na transição solto -> pressionado
    if (atual != BOTAO_INVALIDO) {
        switch (atual) {
            case BOTAO_A: Serial.println("O Professor apertou a opcao 'A'"); return BOTAO_A;
            case BOTAO_B: Serial.println("O Professor apertou a opcao 'B'"); return BOTAO_B;
            case BOTAO_C: Serial.println("O Professor apertou a opcao 'C'"); return BOTAO_C;
            case BOTAO_D: Serial.println("O Professor apertou a opcao 'D'"); return BOTAO_D;
        }
    }
    return BOTAO_INVALIDO; // transição pressionado->solto não gera evento
}

void Util::escreverDado(uint8_t device, uint8_t byte)
{
    Wire.beginTransmission(device);
    Wire.write(byte);
    Wire.endTransmission();
    delay(1);
}

uint8_t Util::lerBotao(uint8_t device, uint8_t count, uint8_t mask)
{
    Wire.requestFrom(device, count);
    uint8_t byte = Wire.read();
    byte = byte & mask;

    return byte;
}

Adafruit_LiquidCrystal lcd(0x27);

unsigned long tempo_segundos = 0;

Jogo jogo(3);
unsigned long tempo_anterior = 0;

void setup() {
  Serial.begin(9600);
  lcd.begin(16, 2);
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Configurado.");

  jogo.professor = Professor('P', PROFESSOR);
  jogo.jogador[0] = Jogador('A', PLAYER_A);
  jogo.jogador[1] = Jogador('B', PLAYER_B);
  jogo.jogador[2] = Jogador('C', PLAYER_C);
  jogo.jogador[3] = Jogador('D', PLAYER_D);
  jogo.jogador[4] = Jogador('E', PLAYER_E);
  jogo.jogador[5] = Jogador('F', PLAYER_F);

  jogo.reiniciar_jogadores();

  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Jogo iniciado!");
}

void loop() {
  if (jogo.ativo) {
    Serial.print("Definindo resposta...");
    lcd.clear();
    lcd.setCursor(5, 0);
    lcd.print("Gerando");
    lcd.setCursor(3, 1);
    lcd.print("Pergunta...");
    Botao resposta_certa = jogo.definir_resposta_certa();



    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Iniciando em...");
    lcd.setCursor(0, 4);

    for (uint8_t i = 3; i > 0; i--) {
      lcd.setCursor(5, 4);
      lcd.print(i);
      lcd.print(" segundos");
      delay(3 * 1000);
    }
    lcd.clear();
    lcd.setCursor(6, 0);
    lcd.print("Vai!");



    jogo.verificar_botoes_jogadores();
    jogo.pontuar_jogadores(resposta_certa, 1);
    jogo.redefinir_respostas_jogadores();

    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("PLA|");
    lcd.setCursor(0, 1);
    lcd.print("CAR|");

    uint8_t index_jogador = 0;
    for (uint8_t i = 5; i <= 15 && index_jogador < 6; i += 2) {
      lcd.setCursor(i, 0);  // Coluna, Linha
      lcd.print(jogo.jogador[index_jogador].obterNome());
      lcd.setCursor(i, 1);  // Coluna, Linha
      lcd.print(jogo.jogador[index_jogador].obterPontuacao());
      index_jogador++;
    }
    jogo.finalizarJogo();
  }
  unsigned long tempo_atual = millis();
  Botao botao_pressionado = jogo.professor.verificarBotaoPressionado();

  if (botao_pressionado == BOTAO_A && tempo_atual - tempo_anterior >= 1000) {
    tempo_anterior = tempo_atual;
    tempo_segundos++;
    if (tempo_segundos >= 2) {
      jogo.iniciar_jogo();
      tempo_segundos = 0;
    }
  }
}
